+++
date = '2025-07-07T10:05:00+08:00'
draft = true
title = '多路图像对齐方案'
tags = ['系统设计']
toc = true
+++

# 多路图像对齐方案

## 背景

在有多源数据需要对齐的场景中，如果有多路图像，就需要先在图像内部对齐，然后对齐的一组图像再和其它数据对齐。

现在假设某机器人上 7 路相机，所以有 7 路相机的图像需要对齐，它们分别是：前视 120 度相机（F120）、前视 30 度相机（F30）、尾部相机（R）、左前相机（FL）、右前相机（FR）、左后相机（RF）和右后相机（RR）。其中以前视 120 度相机为主相机，以前视 120 相机图像的曝光结束时间戳为相机图像数据之间的对齐基准。

实际上，初始化时每个相机对应一个接口实例，通过该接口为每个相机设置回调函数`OnImage`。相机驱动程序启动后，会在相机曝光完成时，通过注册给它的的调函数，将图像数据发送给上层处理模块。

换句话说，整个接收图像的链路可以这样理解：每个相机采集到新图像后，都会通过回调把数据推送到对齐模块。对齐模块会把这些图像按照主相机的时间戳分组，等到同一时刻的所有相机图像都收齐了，就把它们对齐成一组，并发布给后续模块使用。整个过程中，系统会自动管理和清理缓存，保证数据实时、完整且高效。

因此相机图像数据对齐模块有 3 个重要的接口：

1. **`OnImage`**：提供给各相机驱动的回调函数，负责接收图像数据并将其插入原始帧缓存，同时尝试将新图像和原始帧缓存中图像对齐。当对齐一帧后，触发对齐并发布对齐结果。
2. **`UpdateCache`**：在对齐完成后，将对齐好的多路图像帧插入对齐帧缓存（发布缓存），并根据缓存大小策略清理过期数据，供后续模块获取。
3. **`GetAligned`**：根据对齐基准（如主相机时间戳或外部触发消息），从对齐帧缓存中查找并返回最接近基准时间戳的一组对齐好的多路图像数据，供上层模块消费。

这三个接口分别对应：原始数据的接收与对齐、对齐结果的缓存与管理、以及对齐数据的获取，形成了完整的多路图像对齐数据流。

## 接收并对齐

**对齐逻辑**

`OnImage` 是整个多路图像对齐流程的入口。每当任意一路相机采集到新图像时，驱动会通过回调机制调用 `OnImage`，将该相机的图像数据推送进来。`OnImage` 的核心职责是：

- **数据归集**：每个相机采集到新图像后，回调 `OnImage`触发，它会根据该图像的时间戳，将其插入到原始帧缓存`raw_frames_cache_`中。原始帧缓存是一个以图像时间戳为 key，相机 id 到图像数据的 `std::map` 为 value 的 `std::map`。就是桶排序，按照图像时间戳升序排列。
  - 收到新图像后，遍历一次 `raw_frames_cache_`，查找是否有桶其时间戳与新图像时间戳接近（时间戳差值小于阈值 `delta_ts_`，值为 10ms），如果找到，则认为新图像属于该桶（与桶中图像属于同一帧），则将其插入该桶，并标记该路图像的 `aligned` 为 `true`，归并后的桶记为 `raw_frame_aligned_cache`。
  - 如果没有找到接近的桶（如启动时缓存为空，或新图像时间戳大于所有已知桶的时间戳），则新建一个桶，将新图像插入，并标记 `aligned` 为 `true`，将新桶记为 `raw_frame_aligned_cache`。
  - 这样每次新图像到来都能归并到最近的帧，或新建一帧，保证多路图像按时间戳对齐，即完成数据归集之后，`raw_frame_aligned_cache`就是新图像对应的帧。
- **触发对齐**：检查`raw_frame_aligned_cache`的大小是否为 7，若为 7，则说明新图像属于的这一帧已经对齐了（凑够一帧需要的 7 路图像了，且它们之间时间戳差值小于 10ms）则将这一帧`raw_frame_aligned_cache`发送到下游。
  - 当然工程代码为了健壮筑还需要检查`aligned`是否为`false`，毕竟数据归集可能发生意料之外的情况，导致新图像没有被归集，`raw_frame_aligned_cache`为空。
- **缓存管理**：`OnImage` 的最后还会遍历原始帧缓存`raw_frames_cache_`，根据缓存策略清理过期的时间戳，防止内存泄漏和历史数据堆积。

**设计与思考总结**

- 多路相机异步采集，数据到达顺序不确定，必须有统一入口和聚合机制，才能实现“同一时刻”多路图像的对齐，这个统一对齐的地方就是`raw_frames_cache_`，所有到达的图像数据先暂时在这里停留整理。
- 图像数据通过智能指针管理，归集和对齐过程中不会发生多余复制，保证了内存高效和实时性。
- 以时间戳为 key 的有序 map 设计，天然支持帧的顺序管理和最近邻查找，方便归并、清理和异常处理。
- 每个桶（帧）就是一组时间接近的多路图像，只有当一帧齐全才会发布，保证数据完整性和一致性。
- 这种设计便于后续模块按需获取对齐好的帧，且为丢帧、乱序等异常情况提供了容错空间，可灵活调整阈值和策略。
- 随着相机数量增加或帧率提升，缓存管理策略（如过期清理、桶数量限制）变得更重要，否则容易造成内存膨胀或实时性下降。

其实原始帧缓存队列和发布帧缓存队列可以看作是分级队列。

**分级队列的好处总结：**

- **读写分离**：原始帧队列负责归集和对齐（写入、更新），发布帧队列负责下游消费（读取），互不干扰，提升系统并发和稳定性。
- **数据一致性和完整性**：只有对齐好的完整帧才会进入发布队列，保证下游模块拿到的数据是可靠的。
- **解耦处理流程**：对齐逻辑和消费逻辑分离，便于维护和扩展，支持多种下游处理方式。
- **高效缓存管理**：每层队列可以独立设置缓存策略（如过期清理、大小限制），灵活应对不同负载和场景。（本例中两个队列大小限制是一样的）
- **容错与异常处理**：分级队列结构有助于应对丢帧、乱序等异常情况，提升系统健壮性。
- **支持异步和多消费者**：发布队列可以支持多个下游模块异步获取数据，提升整体吞吐和响应速度。

## 对齐结果的发布与缓存

每当 `OnImage` 对齐出一帧（即收齐所有相机的图像并完成归集），就会将这一帧数据通过中间件发送出去饶一圈传递给 `UpdateCache`，将对齐好的帧存储到 `raw_frames_pub_cache_` 中。`raw_frames_pub_cache_`和`raw_frames_cache_`结构相同，也是时间戳升序的桶。`raw_frames_pub_cache_`才是获取对齐图像数据是实际会被搜索的缓存。每次发布缓存更新之后也会清理过期数据。

这样做的目的和考虑如下：

- **数据流分层**：`raw_frames_cache_` 负责原始数据的归集和对齐，`raw_frames_pub_cache_` 专门存储已经对齐好的帧，便于后续模块（如 InputAlignNode）按需获取。
- **解耦与高效发布**：对齐和发布分离，保证对齐逻辑和下游消费逻辑互不干扰，提高系统健壮性和扩展性。
- **数据一致性**：只有对齐好的帧才会进入发布缓存，保证下游模块拿到的数据是完整且一致的。
- **支持异步和多消费者**：发布缓存可以支持多个下游模块异步获取，提升系统并发能力。

两者区别总结：

- `raw_frames_cache_`：原始帧缓存，负责多路图像的归集和对齐，数据可能不完整，随时更新和清理。
- `raw_frames_pub_cache_`：发布帧缓存，只存储已经对齐好的完整帧，供下游模块查找和消费。
- 两者清理过期数据时的缓存大小限制其实一样。

## 获取对齐数据

通过`GetAligned`检索`raw_frames_pub_cache_`即可，由于其按照时间戳升序排序，逆序遍历即可。耗费资源的图像转换也可以在这一步进行，相当于延迟转换。
