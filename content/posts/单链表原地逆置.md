+++
date = '2020-11-28T22:59:00+08:00'
slug = 'singly-linked-list-reverse-in-place'
draft = false
title = '线索二叉树的线索化及遍历'
tags = ['C++', '数据结构', '链表']
toc = false
+++

给定一个带头结点的单链表，编写算法将其原地逆置。所谓“原地”是指空间复杂度为 O(1)。有两种方法，头插法和冒泡法。这两种方法的时间复杂度均为 O(n)。

<!--more-->

# 头插法

## 思路

我们知道，用头插法建立链表，得到的链表中元素的顺序和输入的顺序相反，所以利用这一特点，可以将链表逆置。

给定一个带头结点的单链表 L，如下图所示。

![2020-11-28-单链表原地逆置-1](/singly-linked-list-reverse-in-place/singly-linked-list-reverse-in-place-1.png)

首先用指针 p 存储链表第一个结点，然后将头结点从链表中剥离下来，如下图所示，此时链表 L 只有一个头结点。

![2020-11-28-单链表原地逆置-2](/singly-linked-list-reverse-in-place/singly-linked-list-reverse-in-place-2.png)

另设一指针 r 保存 p 的后继，将 p 指向的结点 N1 用尾插法插入到链表 L 中，

![2020-11-28-单链表原地逆置3](/singly-linked-list-reverse-in-place/singly-linked-list-reverse-in-place-3.png)

此时 p 指向 N2，保存 p 的后继 N3，再将 N2 尾插到链表 L 中，

![2020-11-28-单链表原地逆置-4](/singly-linked-list-reverse-in-place/singly-linked-list-reverse-in-place-4.png)

以此类推，直至保存后继的指针 r 为空，退出循环。

## 头插法的实现代码

```c
void Reverse_L1(Linklist L)
{
    /* p 为工作指针, r 为 p 的后继, 以防断链. */
    LNode *p, *r;

    /* 从第一个元素开始. */
    p = L->next;

    /* 先将头结点剥离出来. */
    L->next = NULL;

    /* 依次将元素摘下. */
    while (p != NULL)
    {
        /* 暂存 p 的后继. */
        r = p->next;
        /* 用头插法插入 p. */
        p->next = L->next;
        L->next = p;
        /* 更新 p, 指向下一个结点. */
        p = r;
    }

    return;
}

```

# 冒泡法

我把这种方法称为“冒泡法”，是因为算法流程和冒泡排序类似，只不过在冒泡排序中是相邻的元素出现逆序才交换，而链表逆置则要求每对结点之间都要交换顺序。

## 思路

冒泡法和头插法不同，头插法只有一个工作指针 p 指向一个操作对象——被摘下来的结点，以及存储其后继的指针 r。而冒泡法有两个工作指针，即一对工作指针，以及存储其后继的指针 r，共计 3 个指针。考虑如下一般情况，

![2020-11-28-单链表原地逆置-5](/singly-linked-list-reverse-in-place/singly-linked-list-reverse-in-place-5.png)

指针 pre 和 p 分别指向两个结点，将其看作一对结点，它们是每次循环操作的对象。循环中，让 N2 的后继指向 N1，即完成了(N1,N2)的逆置。之后三个指针进一，pre=p，p=r，r=r->next，重复上述逆置操作，链表变成了下图。

![2020-11-28-单链表原地逆置-6](/singly-linked-list-reverse-in-place/singly-linked-list-reverse-in-place-6.png)

显而易见，如果指针`r!=NULL`，则循环还要继续下去，若`r==NULL`，循环结束，链表逆置完成，而指针 p 指向逆置后的一个元素。

上述步骤发生的前提是链表中除了头结点以外，至少有两个结点，而为了将判断是否继续循环和是否进入循环结合起来，应将指针 r 初始置为指向第一个结点的后继，p 指向第一个结点，即`p=L->next,r=p->next`，指针 pre 无强制要求。

注意初始 p 指向的结点在完成逆置之后将成为最后一个结点，所以应该在逆置之前将 p 的后继置为空，否则逆置之后 p 的后继会指向倒数第二个结点，而倒数第二个结点的后继指向倒数第一个结点，即逆置前的 p，两个结点之间形成环。

## 冒泡法的实现代码

```c
void Reverse_L2(Linklist L)
{
    /**
     * 三个指针, p 为要反转的结点, pre 为 p 前面的结点, r 是保存 p 后继的指针.
     * 初始状态 p 指向第一个元素, r 指向第二个元素.
     */
    LNode *pre = L, *p = L->next, *r = p->next;

    /**
     * 将要第一个结点后继链接断开. 因为它将成为逆置后链表的最后一个结点, 否则
     * 将在逆置后的链表中的最后一个元素和倒数第二个元素之间形成环.
     */
    p->next = NULL;

    /**
     * 如果 r 不为空, 三个指针前进一个单位.
     * 否则链表只有一个结点, 直接执行 while 后的 L->next = p.
     * 循环中将 p 反转指向其前面的结点 pre, r 是 p 的后继.
     * 假设链表有 n 个元素, 则循环可将前 n - 1 个元素逆置,
     * 之后 p 指向第 n 个元素.
     */
    while (r != NULL)
    {
        /* 指针依次进一. */
        pre = p;
        p = r;
        r = r->next;
        /* 逆置. */
        p->next = pre;
    }

    /* 头结点指向逆置之后的第一个结点. */
    L->next = p;

    return;
}

```

# 代码仓库

1. [data-structure/linklist.c at master · tianshihao/data-structure (github.com)](https://github.com/tianshihao/data-structure/blob/master/src/linearlist/linklist.c)
