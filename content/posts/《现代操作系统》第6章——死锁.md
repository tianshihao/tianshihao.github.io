+++
date = '2024-06-05T15:26:00+08:00'
draft = false
title = '《现代操作系统》第 6 章——死锁'
tags = ['操作系统']
author = 'tianshihao'
toc = true
series = ['现代操作系统笔记']
+++

# 《现代操作系统》第 6 章——死锁

## 6.1 资源

### 6.1.1 可抢占资源和不可抢占资源

### 6.1.2 资源获取

## 6.2 死锁介绍

死锁的规范定义如下：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。

由于所有的进程都在等待，所以没有一个进程能引发可以唤醒该进程集合中的其他进程的事件，这样，所有的进程都只好无限期等待下去。

在大多数情况下，每个进程所等待的事件是释放进程集合中其他进程所占有的资源。换言之，这一死锁进程集合中的每一个进程都在等待另一个死锁的进程已经占有的资源。这种死锁称为资源死锁（resource deadlock）。这是最常见的类型，但并不是唯一的类型。

### 6.2.1 资源死锁的条件

四个必要条件：

1. 互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。
2. 占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。
3. 不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它地进程显式地释放。
4. 环路等待条件。死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。

### 6.2.2 死锁建模

## 6.3 鸵鸟算法

## 6.4 死锁检测和死锁恢复

### 6.4.1 每种类型一个资源的死锁检测

### 6.4.2 每种类型多个资源的死锁检测

### 6.4.3 从死锁中恢复

## 6.5 死锁避免

### 6.5.1 资源轨迹图

### 6.5.1 安全状态和不安全状态

### 6.5.1 单个资源的银行家算法

### 6.5.1 多个资源的银行家算法

## 6.6 死锁预防

### 6.6.1 破坏互斥条件

### 6.6.2 破坏占有并等待条件

### 6.6.3 破坏不可抢占条件

### 6.6.4 破坏环路等待条件

## 6.7 其他问题

### 6.7.1 两阶段加锁

### 6.7.2 通信死锁

### 6.7.3 活锁

### 6.7.4 饥饿

## 6.8 有关死锁的研究

## 6.9 小结

这一章太理论了，还是结合具体编程语言讨论死锁问题好一些。
