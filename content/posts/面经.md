+++
date = '2025-12-08T09:53:00+08:00'
draft = false
title = 'C++面经'
tags = ['C++'， '面试']
toc = true
+++

狗屎

# 快速排序

## 整体思路

快速排序（Quick Sort）是一种分治法排序算法，平均时间复杂度O(nlogn)。

核心思想是：

1. 选取一个“基准”（pivot）元素。
2. 将数组分成两部分：小于基准的放左边，大于等于基准的放右边。
3. 对左右两部分递归排序。

```cpp
#include <iostream>
#include <vector>

int partition(std::vector<int>& arr, int left, int right) {
  auto pivot{arr[right]};
  auto i{left};
  for (auto j{left}; j < right; ++j) {
    if (arr[j] < pivot) {
      std::swap(arr[i], arr[j]);
      ++i;
    }
  }
  std::swap(arr[i], arr[right]);
  return i;
}

void QuickSort(std::vector<int>& arr, int left, int right) {
  if (left >= right) {
    return;
  }  auto pivot_pos{partition(arr, left, right)};
  QuickSort(arr, left, pivot_pos - 1);
  QuickSort(arr, pivot_pos + 1, right);
}

int main() {
  std::vector<int> nums{5, 2, 9, 1, 5, 6};
  QuickSort(nums, 0, nums.size() - 1);

  for (auto n : nums) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
  return 0;
}
```

## 代码解释

因为快排使用的是分治的思想，小于基准的放到左边，大于基准的放到右边，所以关键是如何分区，即`Partition`函数。

### Partition

1. 选取基准

```cpp
  auto pivot{arr[right]};
```

这里选取当前区间最右边的元素作为基准。

2. 分区过程

```cpp
  auto i{left};
  for (auto j{left}; j < right; ++j) {
    if (arr[j] < pivot) {
      std::swap(arr[i], arr[j]);
      ++i;
    }
  }
```

- 用`i`指向“小于pivot的区域末尾”。
- 用`j`遍历整个区间。
- 如果`arr[j] < pivot`，就把它交换到前面（`i`的位置），并移动`i`，相当于拓展“小于pivot区域的边界”。
- 如果`arr[j] >= pivot`，则不更新`i`，相当于“小于pivot区域的边界”就是这个大于pivot的`arr[j]`。

3. 把pivot放到正确的位置

```cpp
  std::swap(arr[i], arr[right]);
  return i;
```

- 完成遍历区间之后，`i`指向“小于pivot的区域末尾”，`i`之前的比pivot小，`i`（包括）之后的比pivot大。
- 最后把pivot放到`i`的位置，这样`i`左边都是小于pivot，右边都大于等于pivot。
- 返回`i`，即pivot的最终位置。

### 递归

对当前区间分区之后，就可以使用获取到的pivot的最终位置就当前区间分为两部分继续递归排序了。

```cpp
  QuickSort(arr, left, pivot_pos - 1);
  QuickSort(arr, pivot_pos + 1, right);
```

注意递归结束的条件，`left >= right`即递归结束。
